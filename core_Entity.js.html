<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: core/Entity.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: core/Entity.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>var artemis;
(function (artemis) {
    var BitSet = artemis.utils.BitSet;
    var UUID = artemis.utils.UUID;
    /**
    * The entity class. Cannot be instantiated outside the framework, you must
    * create new entities using World.
    *
    * @author Arni Arent
    *
    */
    var Entity = (function () {
        function Entity(world, id) {
            this.world_ = world;
            this.id_ = id;
            this.entityManager_ = world.getEntityManager();
            this.componentManager_ = world.getComponentManager();
            this.systemBits_ = new BitSet();
            this.componentBits_ = new BitSet();
            this.reset();
        }
        /**
        * The internal id for this entity within the framework. No other entity
        * will have the same ID, but ID's are however reused so another entity may
        * acquire this ID if the previous entity was deleted.
        *
        * @return id of the entity.
        */
        Entity.prototype.getId = function () {
            return this.id_;
        };
        /**
        * Returns a BitSet instance containing bits of the components the entity possesses.
        * @return
        */
        Entity.prototype.getComponentBits = function () {
            return this.componentBits_;
        };
        /**
        * Returns a BitSet instance containing bits of the components the entity possesses.
        * @return
        */
        Entity.prototype.getSystemBits = function () {
            return this.systemBits_;
        };
        /**
        * Make entity ready for re-use.
        * Will generate a new uuid for the entity.
        */
        Entity.prototype.reset = function () {
            this.systemBits_.clear();
            this.componentBits_.clear();
            this.uuid = UUID.randomUUID();
        };
        Entity.prototype.toString = function () {
            return "Entity[" + this.id_ + "]";
        };
        Entity.prototype.createComponent = function (componentKlazz) {
            var args = [];
            for (var _i = 1; _i &lt; arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
            var componentManager = this.world_.getComponentManager();
            var component = componentManager.create(this, componentKlazz);
            if (args.length) {
                (_a = component).initialize.apply(_a, args);
            }
            var tf = this.world_.getComponentManager().typeFactory;
            var componentType = tf.getTypeFor(componentKlazz);
            this.componentBits_.set(componentType.getIndex());
            return component;
            var _a;
        };
        /**
              * Add a component to this entity.
              *
              * @param component to add to this entity
              *
              * @return this entity for chaining.
              */
        // public addComponent(component: Component):Entity {
        // 	this.addComponent(component, ComponentType.getTypeFor(component.getClass()));
        // 	return this;
        // }
        /**
        * Faster adding of components into the entity. Not neccessery to use this, but
        * in some cases you might need the extra performance.
        *
        * @param component the component to add
        * @param args of the component
        *
        * @return this entity for chaining.
        */
        //public addComponent(component:Component, type?:ComponentType):Entity {
        Entity.prototype.addComponent = function (component) {
            var args = [];
            for (var _i = 1; _i &lt; arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
            var type;
            if (component instanceof artemis.Component) {
                type = args[0];
            }
            else {
                component = this.createComponent.apply(this, [component].concat(args));
                type = this.getTypeFor(component.constructor);
            }
            if (type === undefined)
                type = this.getTypeFor(component.constructor);
            //type = ComponentType.getTypeFor(component.constructor);
            this.componentManager_.addComponent(this, type, component);
            return this;
        };
        Entity.prototype.getTypeFor = function (c) {
            return this.world_.getComponentManager().typeFactory.getTypeFor(c);
        };
        /**
        * Removes the component from this entity.
        *
        * @param component to remove from this entity.
        *
        * @return this entity for chaining.
        */
        Entity.prototype.removeComponentInstance = function (component) {
            //this.removeComponent(ComponentType.getTypeFor(component.constructor));
            this.removeComponent(this.getTypeFor(component.constructor));
            return this;
        };
        /**
        * Faster removal of components from a entity.
        *
        * @param component to remove from this entity.
        *
        * @return this entity for chaining.
        */
        Entity.prototype.removeComponent = function (type) {
            this.componentManager_.removeComponent(this, type);
            return this;
        };
        /**
        * Remove component by its type.
        * @param type
        *
        * @return this entity for chaining.
        */
        Entity.prototype.removeComponentByType = function (type) {
            //this.removeComponent(ComponentType.getTypeFor(type));
            this.removeComponent(this.getTypeFor(type));
            return this;
        };
        /**
        * Checks if the entity has been added to the world and has not been deleted from it.
        * If the entity has been disabled this will still return true.
        *
        * @return if it's active.
        */
        Entity.prototype.isActive = function () {
            return this.entityManager_.isActive(this.id_);
        };
        /**
        * Will check if the entity is enabled in the world.
        * By default all entities that are added to world are enabled,
        * this will only return false if an entity has been explicitly disabled.
        *
        * @return if it's enabled
        */
        Entity.prototype.isEnabled = function () {
            return this.entityManager_.isEnabled(this.id_);
        };
        /**
        * This is the preferred method to use when retrieving a component from a
        * entity. It will provide good performance.
        * But the recommended way to retrieve components from an entity is using
        * the ComponentMapper.
        *
        * @param type
        *            in order to retrieve the component fast you must provide a
        *            ComponentType instance for the expected component.
        * @return
        */
        Entity.prototype.getComponent = function (type) {
            return this.componentManager_.getComponent(this, type);
        };
        // public &lt;T extends Component> T getComponent(Class&lt;T> type) {
        // 	return type.cast(getComponent(ComponentType.getTypeFor(type)));
        // }
        /**
        * Slower retrieval of components from this entity. Minimize usage of this,
        * but is fine to use e.g. when creating new entities and setting data in
        * components.
        *
        * @param &lt;T>
        *            the expected return component type.
        * @param type
        *            the expected return component type.
        * @return component that matches, or null if none is found.
        */
        Entity.prototype.getComponentByType = function (type) {
            return this.componentManager_.getComponent(this, this.getTypeFor(type));
            //return this.componentManager_.getComponent(this, ComponentType.getTypeFor(type));
        };
        /**
        * Returns a bag of all components this entity has.
        * You need to reset the bag yourself if you intend to fill it more than once.
        *
        * @param fillBag the bag to put the components into.
        * @return the fillBag with the components in.
        */
        Entity.prototype.getComponents = function (fillBag) {
            return this.componentManager_.getComponentsFor(this, fillBag);
        };
        /**
        * Refresh all changes to components for this entity. After adding or
        * removing components, you must call this method. It will update all
        * relevant systems. It is typical to call this after adding components to a
        * newly created entity.
        */
        Entity.prototype.addToWorld = function () {
            this.world_.addEntity(this);
        };
        /**
        * This entity has changed, a component added or deleted.
        */
        Entity.prototype.changedInWorld = function () {
            this.world_.changedEntity(this);
        };
        /**
        * Delete this entity from the world.
        */
        Entity.prototype.deleteFromWorld = function () {
            this.world_.deleteEntity(this);
        };
        /**
        * (Re)enable the entity in the world, after it having being disabled.
        * Won't do anything unless it was already disabled.
        */
        Entity.prototype.enable = function () {
            this.world_.enable(this);
        };
        /**
        * Disable the entity from being processed. Won't delete it, it will
        * continue to exist but won't get processed.
        */
        Entity.prototype.disable = function () {
            this.world_.disable(this);
        };
        /**
        * Get the UUID for this entity.
        * This UUID is unique per entity (re-used entities get a new UUID).
        * @return uuid instance for this entity.
        */
        Entity.prototype.getUuid = function () {
            return this.uuid;
        };
        /**
        * Returns the world this entity belongs to.
        * @return world of entity.
        */
        Entity.prototype.getWorld = function () {
            return this.world_;
        };
        return Entity;
    })();
    artemis.Entity = Entity;
})(artemis || (artemis = {}));
//# sourceMappingURL=Entity.js.map</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Global</h3><ul><li><a href="global.html#artemis">artemis</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.3.2</a> on Tue Sep 15 2015 16:40:15 GMT-0700 (PDT)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
